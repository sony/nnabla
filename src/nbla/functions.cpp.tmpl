// Copyright (c) 2018 Sony Corporation. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!
// If you want to modify this file, edit following files.
// - src/nbla/functions.cpp.tmpl
// - build-tools/code_generator/generate.py

#include <vector>
#include <nbla/computation_graph/computation_graph.hpp>
#include <nbla/computation_graph/function.hpp>
#include <nbla/computation_graph/variable.hpp>
#include <nbla/context.hpp>
#include <nbla/function.hpp>
#include <nbla/functions.hpp>
#include <nbla/auto_forward.hpp>

using std::make_shared;
% for name, snake_name, _ in function_list:
#include <nbla/function/${snake_name}.hpp>
% endfor

namespace nbla {
namespace functions {

% for name, snake_name, arg_types in function_list:
## full arguments
<%
fi = function_info[name]

inputs_list = []
inputs_info = fi.get('inputs', [])
if 0 < len(inputs_info):
    inputs_list += ['CgVariablePtr ' + x for x in inputs_info]

args_info = fi.get('arguments', [])
if 0 < len(args_info):
    inputs_list += [x[0] + ' ' + x[1] for x in zip(arg_types, args_info)]

inputs_types = ', '.join(inputs_list)

context_and_inputs = "Context &ctx"
if 0 < len(inputs_list) : context_and_inputs += ", " + inputs_types

inputs = ', '.join(inputs_info)

args = ', '.join(args_info)
if args is not '':
   args = ', ' + args

output_type = 'CgVariablePtr'
output_index = '[0]'
for x in fi['outputs'].values():
    if x['doc'] == 'list of N-D arrays':
       output_type = 'vector<CgVariablePtr>'
       output_index = ''

%>
vector<CgVariablePtr> ${snake_name}(${context_and_inputs}){
  bool auto_forward = SingletonManager::get<AutoForward>()->get_auto_forward();
  return connect(make_shared<CgFunction>(create_${name}(ctx${args})), {${inputs}}, 1, {}, auto_forward);
}

${output_type} ${snake_name}(${inputs_types}){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  bool auto_forward = SingletonManager::get<AutoForward>()->get_auto_forward();
  return connect(make_shared<CgFunction>(create_${name}(global_ctx${args})), {${inputs}}, 1, {}, auto_forward)${output_index};
}
% endfor


ConvolutionOpts::ConvolutionOpts() : group_(1), pad_({ 0, 0 }), stride_({ 1, 1 }), dilation_({ 1, 1 }), channel_last_(false) {}

ConvolutionOpts& ConvolutionOpts::group(int val){
  group_ = val;
  return *this;
}

ConvolutionOpts& ConvolutionOpts::pad(const vector<int> &val) {
  pad_ = val;
  return *this;
}

ConvolutionOpts& ConvolutionOpts::stride(const vector<int> &val) {
  stride_ = val;
  return *this;
}

ConvolutionOpts& ConvolutionOpts::dilation(const vector<int> &val) {
  dilation_ = val;
  return *this;
}

ConvolutionOpts& ConvolutionOpts::channel_last(bool val) {
  channel_last_ = val;
  return *this;
}

DeconvolutionOpts::DeconvolutionOpts() : group_(1), pad_({ 0, 0 }), stride_({ 1, 1 }), dilation_({ 1, 1 }), channel_last_(false), output_padding_({0, 0}) {}

DeconvolutionOpts& DeconvolutionOpts::group(int val){
  group_ = val;
  return *this;
}

DeconvolutionOpts& DeconvolutionOpts::pad(const vector<int> &val) {
  pad_ = val;
  return *this;
}

DeconvolutionOpts& DeconvolutionOpts::stride(const vector<int> &val) {
  stride_ = val;
  return *this;
}

DeconvolutionOpts& DeconvolutionOpts::dilation(const vector<int> &val) {
  dilation_ = val;
  return *this;
}

DeconvolutionOpts& DeconvolutionOpts::channel_last(bool val) {
  channel_last_ = val;
  return *this;
}

DeconvolutionOpts& DeconvolutionOpts::output_padding(const vector<int> &val) {
  output_padding_ = val;
  return *this;
}

BatchNormalizationOpts::BatchNormalizationOpts() : axes_({ 1 }), decay_rate_(0.9), eps_(1.0e-5){}

BatchNormalizationOpts& BatchNormalizationOpts::axes(const vector<int> &val) {
  axes_ = val;
  return *this;
}

BatchNormalizationOpts& BatchNormalizationOpts::decay_rate(float val) {
  decay_rate_ = val;
  return *this;
}

BatchNormalizationOpts& BatchNormalizationOpts::eps(float val) {
  eps_ = val;
  return *this;
}

const vector<int>& BatchNormalizationOpts::axes() const {
  return axes_;
}

float BatchNormalizationOpts::decay_rate() {
  return decay_rate_;
}

float BatchNormalizationOpts::eps() {
  return eps_;
}

PoolingOpts::PoolingOpts() : ignore_border_(false), including_pad_(true), pad_({0, 0}), channel_last_(false) {}

PoolingOpts& PoolingOpts::ignore_border(bool val) {
  ignore_border_ = val;
  return *this;
}

PoolingOpts& PoolingOpts::including_pad(bool val) {
  including_pad_ = val;
  return *this;
}

PoolingOpts& PoolingOpts::pad(const vector<int>& val) {
  pad_ = val;
  return *this;
}

PoolingOpts& PoolingOpts::channel_last(bool val) {
  channel_last_ = val;
  return *this;
}

bool PoolingOpts::ignore_border() const {
  return ignore_border_;
}

bool PoolingOpts::including_pad() const {
  return including_pad_;
}

const vector<int>& PoolingOpts::pad() const {
  return pad_;
}

bool PoolingOpts::channel_last() const {
  return channel_last_;
}

vector<CgVariablePtr> convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts){
  return convolution(ctx, x, weight, bias, base_axis, conv_opts.pad(), conv_opts.stride(), conv_opts.dilation(), group, conv_opts.channel_last());
}

vector<CgVariablePtr> deconvolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, DeconvolutionOpts &opts){
  return deconvolution(ctx, x, weight, bias, base_axis, opts.pad(), opts.stride(), opts.dilation(), group, opts.channel_last(), opts.output_padding());
}

vector<CgVariablePtr> batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, bool no_scale, bool no_bias, BatchNormalizationOpts batch_opts){
  return batch_normalization(ctx, x, beta, gamma, mean, variance, batch_opts.axes(), batch_opts.decay_rate(), batch_opts.eps(), batch_stat, no_scale, no_bias);
}

vector<CgVariablePtr> max_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  return connect(make_shared<CgFunction>(create_MaxPooling(ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad(), pooling_opts.channel_last())), {x});
}

CgVariablePtr max_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  bool auto_forward = SingletonManager::get<AutoForward>()->get_auto_forward();
  return connect(make_shared<CgFunction>(create_MaxPooling(global_ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad(), pooling_opts.channel_last())), {x}, 1, {}, auto_forward)[0];
}

vector<CgVariablePtr> average_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  return connect(make_shared<CgFunction>(create_AveragePooling(ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad(), pooling_opts.channel_last(), pooling_opts.including_pad())), {x});
}

CgVariablePtr average_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  bool auto_forward = SingletonManager::get<AutoForward>()->get_auto_forward();
  return connect(make_shared<CgFunction>(create_AveragePooling(global_ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad(), pooling_opts.channel_last(), pooling_opts.including_pad())), {x}, 1, {}, auto_forward)[0];
}

vector<CgVariablePtr> sum_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  return connect(make_shared<CgFunction>(create_SumPooling(ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad(), pooling_opts.channel_last())), {x});
}

CgVariablePtr sum_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  bool auto_forward = SingletonManager::get<AutoForward>()->get_auto_forward();
  return connect(make_shared<CgFunction>(create_SumPooling(global_ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad(), pooling_opts.channel_last())), {x}, 1, {}, auto_forward)[0];
}

CgVariablePtr convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return convolution(global_ctx, x, weight, bias, base_axis, conv_opts.pad(), conv_opts.stride(), conv_opts.dilation(), group, conv_opts.channel_last())[0];
}

CgVariablePtr deconvolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, DeconvolutionOpts &opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return deconvolution(global_ctx, x, weight, bias, base_axis, opts.pad(), opts.stride(), opts.dilation(), group, opts.channel_last(), opts.output_padding())[0];
}

CgVariablePtr batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, bool no_scale, bool no_bias, BatchNormalizationOpts batch_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return batch_normalization(global_ctx, x, beta, gamma, mean, variance, batch_opts.axes(), batch_opts.decay_rate(), batch_opts.eps(), batch_stat, no_scale, no_bias)[0];
}

}
}

nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b) { return nbla::functions::add2(a, b, false);}
nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b) { return nbla::functions::sub2(a, b, false);}
nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b) { return nbla::functions::mul2(a, b, false);}
nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b) { return nbla::functions::div2(a, b, false);}

nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const float &b) { return nbla::functions::add_scalar(a, b, false);}
nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const float &b) { return nbla::functions::mul_scalar(a, b, false);}
nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const float &b) { return nbla::functions::add_scalar(a, -b, false);}
nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const float &b) { return nbla::functions::mul_scalar(a, 1.0/b, false);}

nbla::CgVariablePtr operator+(const float &a, const nbla::CgVariablePtr &b) { return nbla::functions::add_scalar(b, a, false);}
nbla::CgVariablePtr operator*(const float &a, const nbla::CgVariablePtr &b) { return nbla::functions::mul_scalar(b, a, false);}
nbla::CgVariablePtr operator-(const float &a, const nbla::CgVariablePtr &b) { return nbla::functions::r_sub_scalar(b, a);}
nbla::CgVariablePtr operator/(const float &a, const nbla::CgVariablePtr &b) { return nbla::functions::r_div_scalar(b, a);}
