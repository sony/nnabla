// Copyright (c) 2018 Sony Corporation. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!
// If you want to modify this file, edit following files.
// - src/nbla/functions.cpp.tmpl
// - build-tools/code_generator/generate.py

#include <vector>
#include <nbla/computation_graph/computation_graph.hpp>
#include <nbla/computation_graph/function.hpp>
#include <nbla/computation_graph/variable.hpp>
#include <nbla/context.hpp>
#include <nbla/function.hpp>
#include <nbla/functions.hpp>

using std::make_shared;
% for name, snake_name, _ in function_list:
#include <nbla/function/${snake_name}.hpp>
% endfor

namespace nbla {
namespace functions {

% for name, snake_name, arg_types in function_list:
## full arguments
<%
fi = function_info[name]
type_args = None
args = None
type_inputs = None
inputs = None
if 'arguments' in fi:
    args_info = fi['arguments']
    if 0 < len(args_info):
	    type_args = ', '.join([x[0] + ' ' + x[1] for x in zip(arg_types, args_info)])
	    args = ', '.join(args_info)
if 'inputs' in fi :
    inputs_info = fi['inputs']
    if 0 < len(inputs_info):
	    type_inputs = ', '.join(['CgVariablePtr ' + x for x in inputs_info])
	    inputs = ', '.join(inputs_info)
%>

% if type_args is None and type_inputs is None:
	vector<CgVariablePtr> ${snake_name}(Context &ctx){
	  return connect(make_shared<CgFunction>(create_${name}(ctx)));
	}

	CgVariablePtr ${snake_name}(){
	  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
	  return connect(make_shared<CgFunction>(create_${name}(global_ctx)))[0];
	}
% elif type_args is None:
	vector<CgVariablePtr> ${snake_name}(Context &ctx, ${type_inputs}){
	  return connect(make_shared<CgFunction>(create_${name}(ctx)), {${inputs}});
	}

	CgVariablePtr ${snake_name}(${type_inputs}){
	  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
	  return connect(make_shared<CgFunction>(create_${name}(global_ctx)), {${inputs}})[0];
	}
% elif type_inputs is None:
	vector<CgVariablePtr> ${snake_name}(Context &ctx, ${type_args}){
	  return connect(make_shared<CgFunction>(create_${name}(ctx, ${args})), {});
	}

	CgVariablePtr ${snake_name}(${type_args}){
	  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
	  return connect(make_shared<CgFunction>(create_${name}(global_ctx, ${args})), {})[0];
	}
% else:
	vector<CgVariablePtr> ${snake_name}(Context &ctx, ${type_inputs}, ${type_args}){
	  return connect(make_shared<CgFunction>(create_${name}(ctx, ${args})), {${inputs}});
	}

	CgVariablePtr ${snake_name}(${type_inputs}, ${type_args}){
	  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
	  return connect(make_shared<CgFunction>(create_${name}(global_ctx, ${args})), {${inputs}})[0];
	}
% endif

% endfor


ConvolutionOpts::ConvolutionOpts() : group_(1), pad_({ 0, 0 }), stride_({ 1, 1 }), dilation_({ 1, 1 }){}

ConvolutionOpts& ConvolutionOpts::group(int val){
  group_ = val;
  return *this;
}

ConvolutionOpts& ConvolutionOpts::pad(const vector<int> &val) {
  pad_ = val;
  return *this;
}

ConvolutionOpts& ConvolutionOpts::stride(const vector<int> &val) {
  stride_ = val;
  return *this;
}

ConvolutionOpts& ConvolutionOpts::dilation(const vector<int> &val) {
  dilation_ = val;
  return *this;
}

int ConvolutionOpts::group() {
  return group_;
}

const vector<int>& ConvolutionOpts::pad() const {
  return pad_;
}

const vector<int>& ConvolutionOpts::stride() const {
  return stride_;
}

const vector<int>& ConvolutionOpts::dilation() const {
  return dilation_;
}

BatchNormalizationOpts::BatchNormalizationOpts() : axes_({ 1 }), decay_rate_(0.9), eps_(1.0e-5){}

BatchNormalizationOpts& BatchNormalizationOpts::axes(const vector<int> &val) {
  axes_ = val;
  return *this;
}

BatchNormalizationOpts& BatchNormalizationOpts::decay_rate(float val) {
  decay_rate_ = val;
  return *this;
}

BatchNormalizationOpts& BatchNormalizationOpts::eps(float val) {
  eps_ = val;
  return *this;
}

const vector<int>& BatchNormalizationOpts::axes() const {
  return axes_;
}

float BatchNormalizationOpts::decay_rate() {
  return decay_rate_;
}

float BatchNormalizationOpts::eps() {
  return eps_;
}

PoolingOpts::PoolingOpts() : ignore_border_(false), including_pad_(true), pad_({0, 0}){}

PoolingOpts& PoolingOpts::ignore_border(bool val) {
  ignore_border_ = val;
  return *this;
}

PoolingOpts& PoolingOpts::including_pad(bool val) {
  including_pad_ = val;
  return *this;
}

PoolingOpts& PoolingOpts::pad(const vector<int>& val) {
  pad_ = val;
  return *this;
}

bool PoolingOpts::ignore_border() {
  return ignore_border_;
}

bool PoolingOpts::including_pad() {
  return including_pad_;
}

const vector<int>& PoolingOpts::pad() const {
  return pad_;
}

vector<CgVariablePtr> convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts){
  return convolution(ctx, x, weight, bias, base_axis, conv_opts.pad(), conv_opts.stride(), conv_opts.dilation(), group);
}

vector<CgVariablePtr> deconvolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts){
  return deconvolution(ctx, x, weight, bias, base_axis, conv_opts.pad(), conv_opts.stride(), conv_opts.dilation(), group);
}

vector<CgVariablePtr> batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts){
  return batch_normalization(ctx, x, beta, gamma, mean, variance, batch_opts.axes(), batch_opts.decay_rate(), batch_opts.eps(), batch_stat);
}

vector<CgVariablePtr> max_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  return connect(make_shared<CgFunction>(create_MaxPooling(ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad())), {x});
}

CgVariablePtr max_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return connect(make_shared<CgFunction>(create_MaxPooling(global_ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad())), {x})[0];
}

vector<CgVariablePtr> average_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  return connect(make_shared<CgFunction>(create_AveragePooling(ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad(), pooling_opts.including_pad())), {x});
}

CgVariablePtr average_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return connect(make_shared<CgFunction>(create_AveragePooling(global_ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad(), pooling_opts.including_pad())), {x})[0];
}

vector<CgVariablePtr> sum_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  return connect(make_shared<CgFunction>(create_SumPooling(ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad())), {x});
}

CgVariablePtr sum_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return connect(make_shared<CgFunction>(create_SumPooling(global_ctx, kernel, stride, pooling_opts.ignore_border(), pooling_opts.pad())), {x})[0];
}

CgVariablePtr convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return convolution(global_ctx, x, weight, bias, base_axis, conv_opts.pad(), conv_opts.stride(), conv_opts.dilation(), group)[0];
}

CgVariablePtr deconvolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return deconvolution(global_ctx, x, weight, bias, base_axis, conv_opts.pad(), conv_opts.stride(), conv_opts.dilation(), group)[0];
}

CgVariablePtr batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts){
  auto global_ctx = SingletonManager::get<GlobalContext>()->get_current_context();
  return batch_normalization(global_ctx, x, beta, gamma, mean, variance, batch_opts.axes(), batch_opts.decay_rate(), batch_opts.eps(), batch_stat)[0];
}

}
}

nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b) { return nbla::functions::add2(a, b, false);}
nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b) { return nbla::functions::sub2(a, b);}
nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b) { return nbla::functions::mul2(a, b);}
nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b) { return nbla::functions::div2(a, b);}

nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const float &b) { return nbla::functions::add_scalar(a, b);}
nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const float &b) { return nbla::functions::mul_scalar(a, b);}
nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const float &b) { return nbla::functions::add_scalar(a, -b);}
nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const float &b) { return nbla::functions::mul_scalar(a, 1.0/b);}

nbla::CgVariablePtr operator+(const float &a, const nbla::CgVariablePtr &b) { return nbla::functions::add_scalar(b, a);}
nbla::CgVariablePtr operator*(const float &a, const nbla::CgVariablePtr &b) { return nbla::functions::mul_scalar(b, a);}
nbla::CgVariablePtr operator-(const float &a, const nbla::CgVariablePtr &b) { return nbla::functions::r_sub_scalar(b, a);}
nbla::CgVariablePtr operator/(const float &a, const nbla::CgVariablePtr &b) { return nbla::functions::r_div_scalar(b, a);}
