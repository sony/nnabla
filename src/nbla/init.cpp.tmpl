// Copyright 2018,2019,2020,2021 Sony Corporation.
// Copyright 2021 Sony Group Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!
// If you want to modify this file, edit following files.
// - src/nbla/init.cpp.tmpl
// - build-tools/code_generator/generate.py

#include <nbla/cpu.hpp>
#include <nbla/array_registry.hpp>
#include <nbla/utils/dlpack_array_registry.hpp>
#include <nbla/array/cpu_array.hpp>
#include <nbla/array/cpu_dlpack_array.hpp>
#include <nbla/function_registry.hpp>
#include <nbla/backend_registry.hpp>
% for name, snake_name, _ in function_list:
% if name in function_types:
#include <nbla/function/${snake_name}.hpp>
% endif
% endfor
% for name, snake_name, _ in solver_list:
% if name in solver_types:
#include <nbla/solver/${snake_name}.hpp>
% endif
% endfor

#include <mutex>

namespace nbla {
void init_cpu() {
  static std::mutex m;
  std::lock_guard<std::mutex> lock(m);

  static volatile bool is_initialized = false;
  if (is_initialized)
    return;
  // No branch after this, hence, we should
  // put it here to prevent re-enter.
  is_initialized = true;

  // Backend registration
  NBLA_REGISTER_BACKEND("cpu", []() { return SingletonManager::get<Cpu>(); });

  // Array registration
  NBLA_REGISTER_ARRAY_CREATOR(CpuArray);
  SingletonManager::get<Cpu>()->register_array_class("CpuArray");
  NBLA_REGISTER_ARRAY_CREATOR(CpuCachedArray);
  SingletonManager::get<Cpu>()->register_array_class("CpuCachedArray");
  NBLA_REGISTER_ARRAY_SYNCHRONIZER(CpuArray, CpuCachedArray,
                                   synchronizer_default);
  NBLA_REGISTER_ARRAY_SYNCHRONIZER(CpuCachedArray, CpuArray,
                                   synchronizer_default);
  NBLA_REGISTER_ARRAY_CREATOR(CpuDlpackArray);
  SingletonManager::get<Cpu>()->register_array_class("CpuDlpackArray");
  NBLA_REGISTER_DLPACK_DEVICE_TYPE_TO_CONTEXT(kDLCPU, cpu, CpuDlpackArray);
  NBLA_REGISTER_ARRAY_TO_DLPACK_DEVICE_TYPE(CpuArray, kDLCPU);
  NBLA_REGISTER_ARRAY_TO_DLPACK_DEVICE_TYPE(CpuCachedArray, kDLCPU);
  // It is not necessary that DlpackArray is converted from other arrays.
  NBLA_REGISTER_ARRAY_SYNCHRONIZER(CpuDlpackArray, CpuArray,
                                   synchronizer_default);
  NBLA_REGISTER_ARRAY_SYNCHRONIZER(CpuDlpackArray, CpuCachedArray,
                                   synchronizer_default);

  // Array group registration
  NBLA_REGISTER_ARRAY_GROUP(CpuArray, cpu);
  NBLA_REGISTER_ARRAY_GROUP(CpuCachedArray, cpu);
  NBLA_REGISTER_ARRAY_GROUP(CpuDlpackArray, cpu);
  
  // Function registration
% for name, _, arg_types in function_list:
  % for type_config, ttypes in function_types.get(name, {}).items():
    <%
    ttype_args = ', '.join(ttypes)
    ttype_symbol = ''.join(map(lambda x: x.replace(' ', ''), ttypes))
    function_sym = '{}<{}>'.format(name, ttype_args)
    function_typed_sym = '{}_{}'.format(name, ttype_symbol)
    %> 
  using ${function_typed_sym} = ${function_sym};
  NBLA_REGISTER_FUNCTION_IMPL(${name}, ${function_typed_sym}, "cpu:${type_config}"${''.join(map(lambda x: ', ' + x, arg_types))});
  % endfor
% endfor

  // Solver registration
% for name, _, arg_types in solver_list:
  % for type_config, ttypes in solver_types.get(name, {}).items():
    <%
    ttype_args = ', '.join(ttypes)
    ttype_symbol = ''.join(map(lambda x: x.replace(' ', ''), ttypes))
    solver_sym = '{}<{}>'.format(name, ttype_args)
    solver_typed_sym = '{}_{}'.format(name, ttype_symbol)
    %> 
  using ${solver_typed_sym} = ${solver_sym};
  NBLA_REGISTER_SOLVER_IMPL(${name}, ${solver_typed_sym}, "cpu:${type_config}"${''.join(map(lambda x: ', ' + x, arg_types))});
  %endfor  
% endfor

}

void clear_cpu_memory_cache() {
  SingletonManager::get<Cpu>()->caching_allocator()->free_unused_caches();
}

void print_cpu_memory_cache_map() {
  SingletonManager::get<Cpu>()->caching_allocator()->print_memory_cache_map();
}

/** Get CPU array classes.
*/
vector<string> cpu_array_classes() {
  return SingletonManager::get<Cpu>()->array_classes();
}

/** Set CPU array classes
*/
void _cpu_set_array_classes(const vector<string> &a) {
  return SingletonManager::get<Cpu>()->_set_array_classes(a);
}

void cpu_device_synchronize(const string &device) {
}

int cpu_get_device_count() {
  return 1;
}

vector<string> cpu_get_devices() {
  return {"0"};
}
}
