// Copyright 2019,2020,2021 Sony Corporation.
// Copyright 2021 Sony Group Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!
// If you want to modify this file, edit following files.
// - include/nbla/functions.hpp.tmpl
// - build-tools/code_generator/generate.py

#ifndef __NBLA_FUNCTIONS_HPP__
#define __NBLA_FUNCTIONS_HPP__
#include <vector>

#include <nbla/computation_graph/variable.hpp>
#include <nbla/context.hpp>
#include <nbla/global_context.hpp>
#include <nbla/communicator.hpp>

namespace nbla {
namespace functions {
% for name, snake_name, arg_types in function_list:
## full arguments
<%
fi = function_info[name]

inputs_list_variadic = []
inputs_list = []
inputs_info = fi.get('inputs', [])
if 0 < len(inputs_info):
    for x in inputs_info:
        if inputs_info[x].get('variadic', False):
            inputs_list_variadic += ['vector<CgVariablePtr> ' + x]
        inputs_list += ['CgVariablePtr ' + x]

args_info = fi.get('arguments', [])
argument_list = []
if 0 < len(args_info):
    argument_list += [x[0] + ' ' + x[1] for x in zip(arg_types, args_info)]

def generate_inputs(inputs_list):
    inputs_types = ', '.join(inputs_list + argument_list)
    context_and_inputs = "Context &ctx"
    if 0 < len(inputs_list + argument_list) :
        context_and_inputs += ", " + inputs_types
    return inputs_types, context_and_inputs

inputs_types, context_and_inputs = generate_inputs(inputs_list)
inputs_types_v, context_and_inputs_v = generate_inputs(inputs_list_variadic)

inputs = ', '.join(inputs_info)

args = ', '.join(args_info)
if args != '':
   args = ', ' + args

output_type = 'CgVariablePtr'
output_index = '[0]'
for x in fi['outputs'].values():
    if x['doc'] == 'list of N-D arrays':
       output_type = 'vector<CgVariablePtr>'
       output_index = ''

%>
NBLA_API vector<CgVariablePtr> ${snake_name}(${context_and_inputs});
NBLA_API ${output_type} ${snake_name}(${inputs_types});
% if inputs_list_variadic:
NBLA_API vector<CgVariablePtr> ${snake_name}(${context_and_inputs_v});
NBLA_API ${output_type} ${snake_name}(${inputs_types_v});
% endif
% endfor

class NBLA_API ConvolutionOpts {
private:
  int group_;
  vector<int> pad_;
  vector<int> stride_;
  vector<int> dilation_;
  bool channel_last_;
public:
  ConvolutionOpts();
  ConvolutionOpts &group(int val);
  ConvolutionOpts &pad(const vector<int> &val);
  ConvolutionOpts &stride(const vector<int> &val);
  ConvolutionOpts &dilation(const vector<int> &val);
  ConvolutionOpts &channel_last(bool val);
  int group() { return group_; };
  const vector<int> &pad() const { return pad_; };
  const vector<int> &stride() const { return stride_; };
  const vector<int> &dilation() const {return dilation_; };
  bool channel_last() const { return channel_last_; };
};

class NBLA_API DeconvolutionOpts {
private:
  int group_;
  vector<int> pad_;
  vector<int> stride_;
  vector<int> dilation_;
  bool channel_last_;
  vector<int> output_padding_;
public:
  DeconvolutionOpts();
  DeconvolutionOpts &group(int val);
  DeconvolutionOpts &pad(const vector<int> &val);
  DeconvolutionOpts &stride(const vector<int> &val);
  DeconvolutionOpts &dilation(const vector<int> &val);
  DeconvolutionOpts &channel_last(bool val);
  DeconvolutionOpts &output_padding(const vector<int> &val);
  int group() { return group_; };
  const vector<int> &pad() const { return pad_; };
  const vector<int> &stride() const { return stride_; };
  const vector<int> &dilation() const {return dilation_; };
  bool channel_last() const { return channel_last_; };
  const vector<int> &output_padding() const { return output_padding_; };
};

class NBLA_API BatchNormalizationOpts {
private:
  vector<int> axes_;
  float decay_rate_;
  float eps_;
public:
  BatchNormalizationOpts();
  BatchNormalizationOpts &axes(const vector<int> &val);
  BatchNormalizationOpts &decay_rate(float val);
  BatchNormalizationOpts &eps(float val);
  const vector<int> &axes() const;
  float decay_rate();
  float eps();
};

class NBLA_API PoolingOpts {
private:
  bool ignore_border_;
  bool including_pad_;
  vector<int> pad_;
  bool channel_last_;
public:
  PoolingOpts();
  PoolingOpts &ignore_border(bool ignore_border);
  PoolingOpts &including_pad(bool including_pad);
  PoolingOpts &pad(const vector<int> &val);
  PoolingOpts &channel_last(bool val);
  bool ignore_border() const;
  bool including_pad() const;
  const vector<int> &pad() const;
  bool channel_last() const;
};

NBLA_API vector<CgVariablePtr> convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API vector<CgVariablePtr> deconvolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, DeconvolutionOpts &);
NBLA_API vector<CgVariablePtr> batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts);
NBLA_API vector<CgVariablePtr> max_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API vector<CgVariablePtr> average_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API vector<CgVariablePtr> sum_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());

NBLA_API CgVariablePtr convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API CgVariablePtr deconvolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, DeconvolutionOpts &);
NBLA_API CgVariablePtr batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts);
NBLA_API CgVariablePtr max_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API CgVariablePtr average_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API CgVariablePtr sum_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());

}
}

NBLA_API nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);

NBLA_API nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const float &b);

NBLA_API nbla::CgVariablePtr operator+(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator*(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator-(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator/(const float &a, const nbla::CgVariablePtr &b);
#endif
