// Copyright (c) 2019 Sony Corporation. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!
// If you want to modify this file, edit following files.
// - include/nbla/functions.hpp.tmpl
// - build-tools/code_generator/generate.py

#ifndef __NBLA_FUNCTIONS_HPP__
#define __NBLA_FUNCTIONS_HPP__
#include <vector>

#include <nbla/computation_graph/variable.hpp>
#include <nbla/context.hpp>
#include <nbla/global_context.hpp>

namespace nbla {
namespace functions {
% for name, snake_name, arg_types in function_list:
## full arguments
<%
fi = function_info[name]
type_args = None
args = None
type_inputs = None
inputs = None
if 'arguments' in fi:
    args_info = fi['arguments']
    if 0 < len(args_info):
	    type_args = ', '.join([x[0] + ' ' + x[1] for x in zip(arg_types, args_info)])
	    args = ', '.join(args_info)
if 'inputs' in fi :
    inputs_info = fi['inputs']
    if 0 < len(inputs_info):
	    type_inputs = ', '.join(['CgVariablePtr ' + x for x in inputs_info])
	    inputs = ', '.join(inputs_info)
%>
% if type_args is None and type_inputs is None:
NBLA_API vector<CgVariablePtr> ${snake_name}(Context &ctx);
NBLA_API CgVariablePtr ${snake_name}();
% elif type_args is None:
NBLA_API vector<CgVariablePtr> ${snake_name}(Context &ctx, ${type_inputs});
NBLA_API CgVariablePtr ${snake_name}(${type_inputs});
% elif type_inputs is None:
NBLA_API vector<CgVariablePtr> ${snake_name}(Context &ctx, ${type_args});
NBLA_API CgVariablePtr ${snake_name}(${type_args});
% else:
NBLA_API vector<CgVariablePtr> ${snake_name}(Context &ctx, ${type_inputs}, ${type_args});
NBLA_API CgVariablePtr ${snake_name}(${type_inputs}, ${type_args});
% endif
% endfor

class NBLA_API ConvolutionOpts {
private:
  int group_;
  vector<int> pad_;
  vector<int> stride_;
  vector<int> dilation_;
public:
  ConvolutionOpts();
  ConvolutionOpts &group(int val);
  ConvolutionOpts &pad(const vector<int> &val);
  ConvolutionOpts &stride(const vector<int> &val);
  ConvolutionOpts &dilation(const vector<int> &val);
  int group();
  const vector<int> &pad() const;
  const vector<int> &stride() const;
  const vector<int> &dilation() const;
};

class NBLA_API BatchNormalizationOpts {
private:
  vector<int> axes_;
  float decay_rate_;
  float eps_;
public:
  BatchNormalizationOpts();
  BatchNormalizationOpts &axes(const vector<int> &val);
  BatchNormalizationOpts &decay_rate(float val);
  BatchNormalizationOpts &eps(float val);
  const vector<int> &axes() const;
  float decay_rate();
  float eps();
};

class NBLA_API PoolingOpts {
private:
  bool ignore_border_;
  bool including_pad_;
  vector<int> pad_;
public:
  PoolingOpts();
  PoolingOpts &ignore_border(bool ignore_border);
  PoolingOpts &including_pad(bool including_pad);
  PoolingOpts &pad(const vector<int> &val);
  bool ignore_border();
  bool including_pad();
  const vector<int> &pad() const;
};

NBLA_API vector<CgVariablePtr> convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API vector<CgVariablePtr> deconvolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API vector<CgVariablePtr> batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts);
NBLA_API vector<CgVariablePtr> max_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API vector<CgVariablePtr> average_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API vector<CgVariablePtr> sum_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());

NBLA_API CgVariablePtr convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API CgVariablePtr deconvolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API CgVariablePtr batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts);
NBLA_API CgVariablePtr max_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API CgVariablePtr average_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API CgVariablePtr sum_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());

}
}

NBLA_API nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);

NBLA_API nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const float &b);

NBLA_API nbla::CgVariablePtr operator+(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator*(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator-(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator/(const float &a, const nbla::CgVariablePtr &b);
#endif