// Copyright (c) 2019 Sony Corporation. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!
// If you want to modify this file, edit following files.
// - include/nbla/functions.hpp.tmpl
// - build-tools/code_generator/generate.py

#ifndef __NBLA_FUNCTIONS_HPP__
#define __NBLA_FUNCTIONS_HPP__
#include <vector>

#include <nbla/computation_graph/variable.hpp>
#include <nbla/context.hpp>
#include <nbla/global_context.hpp>
#include <nbla/communicator.hpp>

namespace nbla {
namespace functions {
% for name, snake_name, arg_types in function_list:
## full arguments
<%
fi = function_info[name]

inputs_list = []
inputs_info = fi.get("inputs", [])
if 0 < len(inputs_info):
    inputs_list += ['CgVariablePtr ' + x for x in inputs_info]

args_info = fi.get("arguments", [])
if 0 < len(args_info):
    inputs_list += [x[0] + ' ' + x[1] for x in zip(arg_types, args_info)]

inputs_types = ", ".join(inputs_list)

context_and_inputs = "Context &ctx"
if 0 < len(inputs_list) : context_and_inputs += ", " + inputs_types

output_type = 'CgVariablePtr'
for x in fi['outputs'].values():
    if x['doc'] == 'list of N-D arrays': output_type = 'vector<CgVariablePtr>'

%>
NBLA_API vector<CgVariablePtr> ${snake_name}(${context_and_inputs});
NBLA_API ${output_type} ${snake_name}(${inputs_types});
% endfor

class NBLA_API ConvolutionOpts {
private:
  int group_;
  vector<int> pad_;
  vector<int> stride_;
  vector<int> dilation_;
  bool channel_last_;
public:
  ConvolutionOpts();
  ConvolutionOpts &group(int val);
  ConvolutionOpts &pad(const vector<int> &val);
  ConvolutionOpts &stride(const vector<int> &val);
  ConvolutionOpts &dilation(const vector<int> &val);
  ConvolutionOpts &channel_last(bool val);
  int group() { return group_; };
  const vector<int> &pad() const { return pad_; };
  const vector<int> &stride() const { return stride_; };
  const vector<int> &dilation() const {return dilation_; };
  bool channel_last() const { return channel_last_; };
};

class NBLA_API DeconvolutionOpts {
private:
  int group_;
  vector<int> pad_;
  vector<int> stride_;
  vector<int> dilation_;
  bool channel_last_;
  vector<int> output_padding_;
public:
  DeconvolutionOpts();
  DeconvolutionOpts &group(int val);
  DeconvolutionOpts &pad(const vector<int> &val);
  DeconvolutionOpts &stride(const vector<int> &val);
  DeconvolutionOpts &dilation(const vector<int> &val);
  DeconvolutionOpts &channel_last(bool val);
  DeconvolutionOpts &output_padding(const vector<int> &val);
  int group() { return group_; };
  const vector<int> &pad() const { return pad_; };
  const vector<int> &stride() const { return stride_; };
  const vector<int> &dilation() const {return dilation_; };
  bool channel_last() const { return channel_last_; };
  const vector<int> &output_padding() const { return output_padding_; };
};

class NBLA_API BatchNormalizationOpts {
private:
  vector<int> axes_;
  float decay_rate_;
  float eps_;
public:
  BatchNormalizationOpts();
  BatchNormalizationOpts &axes(const vector<int> &val);
  BatchNormalizationOpts &decay_rate(float val);
  BatchNormalizationOpts &eps(float val);
  const vector<int> &axes() const;
  float decay_rate();
  float eps();
};

class NBLA_API PoolingOpts {
private:
  bool ignore_border_;
  bool including_pad_;
  vector<int> pad_;
  bool channel_last_;
public:
  PoolingOpts();
  PoolingOpts &ignore_border(bool ignore_border);
  PoolingOpts &including_pad(bool including_pad);
  PoolingOpts &pad(const vector<int> &val);
  PoolingOpts &channel_last(bool val);
  bool ignore_border() const;
  bool including_pad() const;
  const vector<int> &pad() const;
  bool channel_last() const;
};

NBLA_API vector<CgVariablePtr> convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API vector<CgVariablePtr> deconvolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, DeconvolutionOpts &);
NBLA_API vector<CgVariablePtr> batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts);
NBLA_API vector<CgVariablePtr> max_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API vector<CgVariablePtr> average_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API vector<CgVariablePtr> sum_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());

NBLA_API CgVariablePtr convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API CgVariablePtr deconvolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, DeconvolutionOpts &);
NBLA_API CgVariablePtr batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts);
NBLA_API CgVariablePtr max_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API CgVariablePtr average_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API CgVariablePtr sum_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());

}
}

NBLA_API nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);

NBLA_API nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const float &b);

NBLA_API nbla::CgVariablePtr operator+(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator*(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator-(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator/(const float &a, const nbla::CgVariablePtr &b);
#endif
