# Copyright (c) 2017 Sony Corporation. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# *WARNING*
# THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
# PLEASE DO NOT EDIT THIS FILE BY HAND!
# If you want to modify this file, edit following files.
# - python/src/nnabla/solver.pyx.tmpl
# - build-tools/code_generator/generate.py

from six.moves import map
from six import iteritems

from libcpp.vector cimport vector
from libcpp.pair cimport pair
from libcpp.unordered_map cimport unordered_map
from libcpp.string cimport string
from libcpp.memory cimport shared_ptr
from libcpp cimport bool as cpp_bool
from libc.stdint cimport int64_t
from cpython cimport Py_INCREF, Py_DECREF

cimport solver
from solver cimport CSolver, CSolverState
cimport _variable
from _variable cimport Variable as _Variable, CVariable

from collections import OrderedDict

# Numpy
import numpy as np
cimport numpy as np
np.import_array()

import nnabla.utils.nnabla_pb2 as nnabla_pb2
import google.protobuf.text_format as text_format

cdef void callback_incref(void *obj) with gil:
    Py_INCREF(<object>obj)

cdef void callback_decref(void *obj) with gil:
    Py_DECREF(<object>obj)

cdef void callback_call_callable(void *obj) except+ with gil:
    cdef object cbl = <object>obj
    cbl()

cdef UpdateHookWithObject create_update_hook_with_object(object callback):
    return UpdateHookWithObject(<void*>callback,
                                <std_function[void(void*)]>callback_call_callable,
                                <std_function[void(void*)]>callback_incref,
                                <std_function[void(void*)]>callback_decref)


class SolverState(object):
    """Solver State
    """
    def __init__(self):
        self.pstate = {}
        self.t = 0


cdef class Solver:
    """Solver interface class.

    The same API provided in this class can be used to implement various types of solvers.

    Example:

    .. code-block:: python

        # Network building comes above
        import nnabla.solvers as S
        solver = S.Sgd(lr=1e-3)
        solver.set_parameters(nn.get_parameters())

        for itr in range(num_itr):
            x.d = ... # set data
            t.d = ... # set label
            loss.forward()
            solver.zero_grad()  # All gradient buffer being 0
            loss.backward()
            solver.weight_decay(decay_rate)  # Apply weight decay
            solver.clip_grad_by_norm(clip_norm)  # Apply clip grad by norm
            solver.update()  # updating parameters

    Note:
        All solvers provided by NNabla belong to an inherited class of ``Solver`` . A solver is never instantiated by this class itself.

    """

    @staticmethod
    cdef create(shared_ptr[CSolver] solver, info):
        s = Solver(info)
        s.info = info
        s.solver = solver
        s.solverp = solver.get()
        return s

    def setup(self, params):
        """
        Deprecated. Call ``set_parameters`` with ``param_dict`` .
        """
        raise RuntimeError("Deprecated. Call set_parameters(param_dict).")

    def set_parameters(self, param_dict, cpp_bool reset=True, cpp_bool retain_state=False):
        """
        Set parameters by dictionary of keys and parameter Variables.

        Args:
            param_dict (dict) : key:string, value: Variable.
            reset (bool): If true, clear all parameters before setting parameters. If false,
                    parameters are overwritten or added (if it's new).
            retain_state (bool): The value is only considered if reset is false. If true and
                           a key already exists (overwriting), a state (such as momentum)
                           associated with the key will be kept if the shape of the parameter
                           and that of the new param match.
        """
        cdef vector[pair[string, shared_ptr[CVariable]]] cparams
        cdef _Variable x
        cdef string key
        cdef int i
        for key, x in iteritems(param_dict):
            cparams.push_back(pair[string, shared_ptr[CVariable]](key, (< _Variable > x).varp.variable()))
        self.solverp.set_parameters(cparams, reset, retain_state)

    def remove_parameters(self, vector[string] keys):
        """
        Remove previously registered parameters, specified by a ``vector`` of its keys.
        """
        self.solverp.remove_parameters(keys)

    def clear_parameters(self):
        """
        Clear all registered parameters and states.
        """
        self.solverp.clear_parameters()

    def get_parameters(self):
        """
        Get all registered parameters
        """
        cdef vector[pair[string, shared_ptr[CVariable]]] cparams;
        cparams = self.solverp.get_parameters()
        params = OrderedDict()
        for elm in cparams:
            name = elm.first
            var = _Variable.create_from_cvariable(elm.second)
            params[name] = var
        return params

    def get_states(self):
        """
        Get all states
        """
        cstates = self.solverp.get_states()
        states = OrderedDict()
        for elm0 in cstates:
            vname = elm0.first
            src_state = elm0.second
            dst_state = SolverState()
            pstate = src_state.pstate
            for elm1 in pstate:
                sname = elm1.first
                var = _Variable.create_from_cvariable(< shared_ptr[CVariable] ?> elm1.second)
                dst_state.pstate[sname] = var
            dst_state.t = src_state.t
            states[vname] = dst_state
        return states

    def set_states(self, states):
        """
        Set states. Call `set_parameters` to initialize states of a solver first, otherwise this method raise an value error.
        """
        cdef vector[pair[string, CSolverState]] cstates
        cdef string pname
        cdef CSolverState dst_cstate
        cdef _Variable pstate
        for pname, src_state in iteritems(states):
            for sname, var in iteritems(src_state.pstate):
                dst_cstate.pstate[sname] = (< _Variable > var).varp.variable()
            dst_cstate.t = src_state.t
            cstates.push_back(pair[string, CSolverState](pname, dst_cstate))
        self.solverp.set_states(cstates)

    def save_states(self, path):
        """
        Save solver states.

        Args:
            path : path or file object
        
        """
        import os
        import nnabla as nn
        states = self.get_states()
        _, ext = os.path.splitext(path)
        if ext == '.h5':
            # TODO temporary work around to suppress FutureWarning message.
            import warnings
            warnings.simplefilter('ignore', category=FutureWarning)
            import h5py
            with h5py.File(path, 'w') as hd:
                # File's key is `/{parameter-name}/{state-name}` and `/{parameter-name}/t`
                for i, (pname, state) in enumerate(iteritems(states)):
                    hd.create_group(pname)
                    hd[pname].create_dataset("t", data=state.t)
                    hd[pname].attrs['index'] = i
                    for j, (sname, vx) in enumerate(iteritems(state.pstate)):
                        hd[pname].create_dataset(sname, data=vx.data.get_data('r'))
                        hd[pname][sname].attrs['index'] = j

        elif ext == '.protobuf':
            optimizer = nnabla_pb2.Optimizer()
            self.set_states_to_protobuf(optimizer)
            with open(path, "wb") as f:
                f.write(optimizer.SerializeToString())
        else:
            nn.logger.critical('Only supported hdf5 or protobuf.')
            assert False
        nn.logger.info("Solver state save ({}): {}".format(ext, path))

    def set_states_to_protobuf(self, optimizer):
        """Set states to the protobuf file from the solver.
        
        Internally used helper method.
        """
        states = self.get_states()
        states_proto = optimizer.solver.states
        for pname, state in iteritems(states):
            state_proto = nnabla_pb2.SolverState()
            state_proto.t = state.t
            for sname, vx in iteritems(state.pstate):
                solver_state_parameter_proto = nnabla_pb2.SolverStateParameter()
                solver_state_parameter_proto.shape.dim.extend(vx.shape)
                solver_state_parameter_proto.data.extend(np.array(vx.d).flatten().tolist())
                state_proto.state_parameter[sname].CopyFrom(solver_state_parameter_proto)
            states_proto[pname].CopyFrom(state_proto)
        
    def load_states(self, path):
        """
        Load solver states.

        Args:
            path : path to the state file to be loaded.
        
        """
        import os
        import nnabla as nn

        states = OrderedDict()

        _, ext = os.path.splitext(path)
        if ext == '.h5':
            # TODO temporary work around to suppress FutureWarning message.
            import warnings
            warnings.simplefilter('ignore', category=FutureWarning)
            import h5py
            with h5py.File(path, 'r') as hd:
                # File's key is `/{parameter-name}/{state-name}` and `/{parameter-name}/t`
                skeys = []
                pkeys = set()
                def _get_skeys(name, obj):
                    if not isinstance(obj, h5py.Dataset):
                        # Group
                        return
                    # state key
                    skeys.append(name)                          
                    # To preserve order of parameters
                    index = obj.parent.attrs.get('index', None)
                    pname = name[:name.rindex("/")]
                    # parameter key
                    pkeys.add((index, pname))
                # TODO Refactoring visit logic for efficient execution
                hd.visititems(_get_skeys)
                for _, pkey in sorted(pkeys):
                    state = SolverState()
                    for skey in skeys:
                        if not skey.startswith(pkey):
                            continue
                        ds = hd[skey]
                        if skey.endswith("/t"):
                            state.t = ds[...]
                        else:
                            sname = skey.split("/")[-1]
                            var = nn.Variable.from_numpy_array(ds[...])
                            state.pstate[sname] = var
                    states[pkey] = state
            self.set_states(states)
        elif ext == '.protobuf':
            optimizer = nnabla_pb2.Optimizer()
            with open(path, 'rb') as f:
                optimizer.MergeFromString(f.read())
                self.set_states_from_protobuf(optimizer)
        elif ext == '.nntxt' or ext == '.prototxt':
            optimizer = nnabla_pb2.Optimizer()
            with open(path, 'r') as f:
                text_format.Merge(f.read(), optimizer)
                self.set_states_from_protobuf(optimizer)
        elif ext == '.nnp':
            raise NotImplementedError("Solver.load_states for nnp format not implemented.")

        nn.logger.info("State load ({}): {}".format(ext, path))

    def set_states_from_protobuf(self, optimizer_proto):
        """Set states to the solver from the protobuf file.
        
        Internally used helper method.
        """
        import nnabla as nn

        states = OrderedDict()
        states_proto = optimizer_proto.solver.states
        for pname, state_proto in iteritems(states_proto):
            state = SolverState()
            state.t = state_proto.t
            for sname, ssp in iteritems(state_proto.state_parameter):
                xd = np.reshape(ssp.data, ssp.shape.dim)
                vx = nn.Variable.from_numpy_array(xd)
                state.pstate[sname] = vx
            states[pname] = state
        self.set_states(states)

    def set_learning_rate(self, learning_rate):
        """
        Set the learning rate.
        """
        self.solverp.set_learning_rate(learning_rate)

    def zero_grad(self):
        """
        Initialize gradients of all registered parameter by zero.
        """

        with nogil:
            self.solverp.zero_grad()

    def update(self, object update_pre_hook=None, object update_post_hook=None):
        """
        When this function is called, parameter values are updated using the gradients accumulated in backpropagation,
        stored in the ``grad`` field of the parameter ``Variable`` s.
        Update rules are implemented in the C++ core,
        in derived classes of Solver. The updated parameter values will be stored into the data field of
        the parameter ``Variable`` s.

        Args:
            update_pre_hook(callable):
                This callable object is called immediately before each update of parameters.
                The default is None.
            update_post_hook(callable):
                This callable object is called immediately after each update of parameters.
                The default is None.
        """
        cdef update_hook_type update_pre_hook_c
        cdef update_hook_type update_post_hook_c

        if update_pre_hook is not None:
            update_pre_hook_c = create_update_hook_with_object(update_pre_hook)
        if update_post_hook is not None:
            update_post_hook_c = create_update_hook_with_object(update_post_hook)

        with nogil:
            self.solverp.update(update_pre_hook_c, update_post_hook_c)

    def weight_decay(self, float decay_rate, object pre_hook=None, object post_hook=None):
        """
        Apply weight decay to gradients.
        When called, the gradient weight will be decayed by a rate of the
        current parameter value.

        Args:
            decay_rate (float): The coefficient of weight decay.
        """
        cdef update_hook_type pre_hook_c
        cdef update_hook_type post_hook_c

        if pre_hook is not None:
            pre_hook_c = create_update_hook_with_object(pre_hook)
        if post_hook is not None:
            post_hook_c = create_update_hook_with_object(post_hook)

        with nogil:
            self.solverp.weight_decay(decay_rate, pre_hook_c, post_hook_c)

    def clip_grad_by_norm(self, float clip_norm, object pre_hook=None, object post_hook=None):
        """
        Clip gradients by norm.
        When called, the gradient will be clipped by the given norm.

        Args:
            clip_norm (float): The value of clipping norm.
        """
        cdef update_hook_type pre_hook_c
        cdef update_hook_type post_hook_c

        if pre_hook is not None:
            pre_hook_c = create_update_hook_with_object(pre_hook)
        if post_hook is not None:
            post_hook_c = create_update_hook_with_object(post_hook)

        with nogil:
            self.solverp.clip_grad_by_norm(clip_norm, pre_hook_c, post_hook_c)

    def check_inf_grad(self, object pre_hook=None, object post_hook=None):
        """
        Check if there is any inf on the gradients which were setup.

        """
        cdef cpp_bool flag;
        cdef update_hook_type pre_hook_c
        cdef update_hook_type post_hook_c

        if pre_hook is not None:
            pre_hook_c = create_update_hook_with_object(pre_hook)
        if post_hook is not None:
            post_hook_c = create_update_hook_with_object(post_hook)
        with nogil:
            flag = self.solverp.check_inf_grad(pre_hook_c, post_hook_c)
        return flag

    def check_nan_grad(self, object pre_hook=None, object post_hook=None):
        """
        Check if there is any nan on the gradients which were setup.

        """
        cdef cpp_bool flag;
        cdef update_hook_type pre_hook_c
        cdef update_hook_type post_hook_c

        if pre_hook is not None:
            pre_hook_c = create_update_hook_with_object(pre_hook)
        if post_hook is not None:
            post_hook_c = create_update_hook_with_object(post_hook)
        with nogil:
            flag = self.solverp.check_nan_grad(pre_hook_c, post_hook_c)
        return flag

    def check_inf_or_nan_grad(self, object pre_hook=None, object post_hook=None):
        """
        Check if there is any inf or nan on the gradients which were setup.

        """
        cdef cpp_bool flag;
        cdef update_hook_type pre_hook_c
        cdef update_hook_type post_hook_c

        if pre_hook is not None:
            pre_hook_c = create_update_hook_with_object(pre_hook)
        if post_hook is not None:
            post_hook_c = create_update_hook_with_object(post_hook)
        with nogil:
            flag = self.solverp.check_inf_or_nan_grad(pre_hook_c, post_hook_c)
        return flag

    def scale_grad(self, scale, object pre_hook=None, object post_hook=None):
        """
        Rescale gradient

        """
        cdef float _scale = scale;
        cdef update_hook_type pre_hook_c
        cdef update_hook_type post_hook_c

        if pre_hook is not None:
            pre_hook_c = create_update_hook_with_object(pre_hook)
        if post_hook is not None:
            post_hook_c = create_update_hook_with_object(post_hook)
        with nogil:
            self.solverp.scale_grad(_scale, pre_hook_c, post_hook_c)
            
    @property
    def name(self):
        """
        Get the name of the solver.
        """
        return self.solverp.name()

    def learning_rate(self):
        """
        Get the learning rate.
        """
        return self.solverp.learning_rate()


def solver_api(func):
    """
    Decorator function which passes a current context to 1st argument of
    a decorated function.

    Args:
        func (function): 1st argument must be a Context.

    """
    import context
    import re
    import inspect
    doc = func.__doc__
    # Parsing signature
    head = doc.splitlines()[0]
    # Extract function name and args
    m = re.match(r'([A-Za-z]\w+)\((.*)\)', head)
    name, rawargs = m.groups()
    # Parse arguments. Note: Here we drop the first argument which is a
    # context.
    r = re.compile(r'(\w+\s|)(\w+)(|=.*)$')
    parsed_args = list(map(
        lambda x: r.match(x.strip()).groups(), rawargs.split(',')[1:]))
    types, args, defaults = zip(*parsed_args)
    types = map(lambda x: x.strip(), types)
    defaults = list(map(lambda x: eval(x), filter(
        lambda x: len(x) > 0, map(lambda x: x.strip(' ='), defaults))))
    # Create argument code.
    argspec = inspect.formatargspec(args, None, None, defaults)
    shortargspec = inspect.formatargspec(
        args, None, None, None)[1:-1]  # Remove ()
    code = """
def {name}{argspec}:
    ctx = context.get_current_context()
    return _func_(ctx, {shortargspec})
    """.format(**locals())
    execdict = dict(_func_=func, context=context)
    exec(code, execdict)
    func_with_context = execdict[name]
    doc = '\n'.join(doc.splitlines()[1:])
    doc += """
    """
    func_with_context.__doc__ = doc
    func_with_context.__solver_api_base__ = func
    func_with_context.__module__ = __name__
    return func_with_context

<%
def arg_field(kv):
    from utils.type_conv import type_from_proto
    name, arg = kv
    '''Make arg info to string expression.'''
    argstr = '{} {}'.format(type_from_proto[arg['type']]['pyx'], name)
    if 'default' in arg:
        argstr += '={}'.format(arg['default'])
    return argstr
%>
%for solver_name, solver in solver_info.items():
@solver_api
def ${solver_name}(CContext ctx, ${', '.join(map(arg_field, solver['arguments'].items()))}):
    r"""
    ${solver['doc'].replace('\n', '\n' + ' ' * 4)}

    Args:
%for argname, arg, in solver['arguments'].items():
        ${argname} (${arg['type']}): ${arg['doc'].replace('\n', '\n' + ' ' * 12)}
%endfor

    Returns:
        ~nnabla.solver.Solver: An instance of Solver class.
            See Solver API guide for details.

    Note:
        You can instantiate a preferred target implementation (ex. CUDA) of
        a Solver given a `Context`. A `Context` can be set by
        ``nnabla.set_default_context(ctx)``
        or ``nnabla.context_scope(ctx)``. See API docs.
%if 'references' in solver:

    References:
%for ref in solver['references']:
        * ${ref.replace('\n', '\n' + ' ' * 10)}
%endfor
%endif

    """
    info = {}
%for argname in solver['arguments'].keys():
    info['${argname}'] = ${argname}
%endfor
    return Solver.create(create_${solver_name}Solver(ctx, ${', '.join(solver['arguments'].keys())}), info)


%endfor 
