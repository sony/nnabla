# Copyright (c) 2017 Sony Corporation. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# *WARNING*
# THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
# PLEASE DO NOT EDIT THIS FILE BY HAND!
# If you want to modify this file, edit following files.
# - python/src/nnabla/solver.pyx.tmpl
# - build-tools/code_generator/generate.py

from six.moves import map
from six import iteritems

from libcpp.vector cimport vector
from libcpp.pair cimport pair
from libcpp.string cimport string
from libcpp.memory cimport shared_ptr
from libcpp cimport bool as cpp_bool
from libc.stdint cimport int64_t

cimport solver
from solver cimport CSolver
cimport _variable
from _variable cimport Variable as _Variable, CVariable

# Numpy
import numpy as np
cimport numpy as np
np.import_array()


cdef class Solver:
    """Solver interface class.

    The same API provided in this class can be used to implement various types of solvers.

    Example:

    .. code-block:: python

        # Network building comes above
        import nnabla.solvers as S
        solver = S.Sgd(lr=1e-3)
        solver.set_parameters(nn.get_parameters())

        for itr in range(num_itr):
            x.d = ... # set data
            t.d = ... # set label
            loss.forward()
            solver.zero_grad()  # All gradient buffer being 0
            loss.backward()
            solver.weight_decay(decay_rate)  # Apply weight decay
            solver.update()  # updating parameters

    Note:
        All solvers provided by NNabla belong to an inherited class of ``Solver`` . A solver is never instantiated by this class itself.

    """

    @staticmethod
    cdef create(shared_ptr[CSolver] solver, info):
        s = Solver(info)
        s.info = info
        s.solver = solver
        s.solverp = solver.get()
        return s

    def setup(self, params):
        """
        Deprecated. Call ``set_parameters`` with ``param_dict`` .
        """
        raise RuntimeError("Deprecated. Call set_parameters(param_dict).")

    def set_parameters(self, param_dict, cpp_bool reset=True, cpp_bool retain_state=False):
        """
        Set parameters by dictionary of keys and parameter Variables.

        Args:
            param_dict (dict) : key:string, value: Variable.
            reset (bool): If true, clear all parameters before setting parameters. If false,
                    parameters are overwritten or added (if it's new).
            retain_state (bool): The value is only considered if reset is false. If true and
                           a key already exists (overwriting), a state (such as momentum)
                           associated with the key will be kept if the shape of the parameter
                           and that of the new param match.
        """
        cdef vector[pair[string, shared_ptr[CVariable]]] cparams
        cdef _Variable x
        cdef string key
        cdef int i
        for key, x in iteritems(param_dict):
            cparams.push_back(pair[string, shared_ptr[CVariable]](key, (< _Variable > x).varp.variable()))
        self.solverp.set_parameters(cparams, reset, retain_state)

    def remove_parameters(self, vector[string] keys):
        """
        Remove previously registered parameters, specified by a ``vector`` of its keys.
        """
        self.solverp.remove_parameters(keys)

    def clear_parameters(self):
        """
        Clear all registered parameters and states.
        """
        self.solverp.clear_parameters()

    def set_learning_rate(self, learning_rate):
        """
        Set the learning rate.
        """
        self.solverp.set_learning_rate(learning_rate)

    def zero_grad(self):
        """
        Initialize gradients of all registered parameter by zero.
        """

        with nogil:
            self.solverp.zero_grad()

    def update(self):
        """
        When this function is called, parameter values are updated using the gradients accumulated in backpropagation,
        stored in the ``grad`` field of the parameter ``Variable`` s.
        Update rules are implemented in the C++ core,
        in derived classes of Solver. The updated parameter values will be stored into the data field of
        the parameter ``Variable`` s.
        """
        with nogil:
            self.solverp.update()

    def weight_decay(self, float decay_rate):
        """
        Apply weight decay to gradients.
        When called, the gradient weight will be decayed by a rate of the
        current parameter value.

        Args:
            decay_rate (float): The coefficient of weight decay.
        """

        with nogil:
            self.solverp.weight_decay(decay_rate)

    def check_inf_grad(self, ):
        """
        Check if there is any inf on the gradients which were setup.

        """
        cdef cpp_bool flag;
        with nogil:
            flag = self.solverp.check_inf_grad()
        return flag

    def check_nan_grad(self, ):
        """
        Check if there is any nan on the gradients which were setup.

        """
        cdef cpp_bool flag;
        with nogil:
            flag = self.solverp.check_nan_grad()
        return flag

    def check_inf_or_nan_grad(self, ):
        """
        Check if there is any inf or nan on the gradients which were setup.

        """
        cdef cpp_bool flag;
        with nogil:
            flag = self.solverp.check_inf_or_nan_grad()
        return flag

    def scale_grad(self, scale):
        """
        Rescale gradient

        """
        cdef float _scale = scale;
        with nogil:
            self.solverp.scale_grad(_scale)
            
    @property
    def name(self):
        """
        Get the name of the solver.
        """
        return self.solverp.name()

    def learning_rate(self):
        """
        Get the learning rate.
        """
        return self.solverp.learning_rate()


def solver_api(func):
    """
    Decorator function which passes a current context to 1st argument of
    a decorated function.

    Args:
        func (function): 1st argument must be a Context.

    """
    import context
    import re
    import inspect
    doc = func.__doc__
    # Parsing signature
    head = doc.splitlines()[0]
    # Extract function name and args
    m = re.match(r'([A-Za-z]\w+)\((.*)\)', head)
    name, rawargs = m.groups()
    # Parse arguments. Note: Here we drop the first argument which is a
    # context.
    r = re.compile(r'(\w+\s|)(\w+)(|=.*)$')
    parsed_args = list(map(
        lambda x: r.match(x.strip()).groups(), rawargs.split(',')[1:]))
    types, args, defaults = zip(*parsed_args)
    types = map(lambda x: x.strip(), types)
    defaults = list(map(lambda x: eval(x), filter(
        lambda x: len(x) > 0, map(lambda x: x.strip(' ='), defaults))))
    # Create argument code.
    argspec = inspect.formatargspec(args, None, None, defaults)
    shortargspec = inspect.formatargspec(
        args, None, None, None)[1:-1]  # Remove ()
    code = """
def {name}{argspec}:
    ctx = context.get_current_context()
    return _func_(ctx, {shortargspec})
    """.format(**locals())
    execdict = dict(_func_=func, context=context)
    exec(code, execdict)
    func_with_context = execdict[name]
    doc = '\n'.join(doc.splitlines()[1:])
    doc += """
    """
    func_with_context.__doc__ = doc
    func_with_context.__solver_api_base__ = func
    func_with_context.__module__ = __name__
    return func_with_context

<%
def arg_field(kv):
    from utils.type_conv import type_from_proto
    name, arg = kv
    '''Make arg info to string expression.'''
    argstr = '{} {}'.format(type_from_proto[arg['type']]['pyx'], name)
    if 'default' in arg:
        argstr += '={}'.format(arg['default'])
    return argstr
%>
%for solver_name, solver in solver_info.items():
@solver_api
def ${solver_name}(CContext ctx, ${', '.join(map(arg_field, solver['arguments'].items()))}):
    r"""
    ${solver['doc'].replace('\n', '\n' + ' ' * 4)}

    Args:
%for argname, arg, in solver['arguments'].items():
        ${argname} (${arg['type']}): ${arg['doc'].replace('\n', '\n' + ' ' * 12)}
%endfor

    Returns:
        ~nnabla.solver.Solver: An instance of Solver class.
            See Solver API guide for details.

    Note:
        You can instantiate a preferred target implementation (ex. CUDA) of
        a Solver given a `Context`. A `Context` can be set by
        ``nnabla.set_default_context(ctx)``
        or ``nnabla.context_scope(ctx)``. See API docs.
%if 'references' in solver:

    References:
%for ref in solver['references']:
        * ${ref.replace('\n', '\n' + ' ' * 10)}
%endfor
%endif

    """
    info = {}
%for argname in solver['arguments'].keys():
    info['${argname}'] = ${argname}
%endfor
    return Solver.create(create_${solver_name}Solver(ctx, ${', '.join(solver['arguments'].keys())}), info)


%endfor 
