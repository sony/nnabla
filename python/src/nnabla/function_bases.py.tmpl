# Copyright (c) 2017 Sony Corporation. All Rights Reserved.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# *WARNING*
# THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
# PLEASE DO NOT EDIT THIS FILE BY HAND!
# If you want to modify this file, edit following files.
# - python/src/nnabla/function_bases.py.tmpl
# - build-tools/code_generator/generate.py

from __future__ import absolute_import

from .context import get_current_context
from . import function as F
from .auto_forward import get_auto_forward

# Templates for function_api source building.
FUNCTION_API_HEADER = "def {name}{signature}:"
FUNCTION_API_BODY = '''ctx = get_current_context()
return _func_(ctx, {shortsignature})'''


def function_api(func):
    """
    Decorator for making function called with current context.
    Some tricky things are done here so that signature and docstring are available.
    """
    from nnabla.utils.py23_compatible import getargspec
    import inspect

    name = func.__name__
    doc = func.__doc__
    if doc is None:
        doc = "No docstring."

    # Parsing argspecs
    spec = getargspec(func)
    defaults = spec.defaults
    if spec.defaults is None:
        defaults = None
    elif len(spec.defaults) == len(spec.args):
        defaults = defaults[1:]
    # Creating signature
    # e.g. (x, weights, biases=None, n_outputs=None)
    signature = inspect.formatargspec(
        spec.args[1:], spec.varargs, spec.keywords, defaults)
    # Creating signature without params and defaults
    # e.g. x, weights, biases, n_outputs
    shortsignature = inspect.formatargspec(
        spec.args[1:], spec.varargs, spec.keywords, None)[1:-1]

    # Create code by string
    src = (FUNCTION_API_HEADER + '\n' + '\n'.join(map(lambda x: '    ' +
                                                      x, FUNCTION_API_BODY.splitlines()))).format(**locals())

    # Evaluate source code from string
    code = compile(src, "<{name}>".format(**locals()), 'single')
    execdict = dict(_func_=func, get_current_context=get_current_context)
    exec(code, execdict)

    # Get created function.
    newfunc = execdict[name]
    # DOC newfunc.__doc__ = FUNCTION_API_DOC.format(**locals())
    doc += '''

    Note:
        All nnabla functions in :obj:`nnabla.functions` are decorated with the :obj:`nnabla.function_bases.function_api` decorator,
        which queries the current context and passes it into the first argument of the
        original function. The original function always takes a context as the first argument.

    '''
    newfunc.__doc__ = doc
    newfunc.__source__ = src
    newfunc.__function_api_base__ = func
    newfunc.__module__ = __name__
    return newfunc

<%
def has_variadic(inputs):
    ret = False
    for i in inputs.values():
        var = i.get('variadic', False)
        if ret:
            raise ValueError('''Variadic input must come at the last of inputs.
            %s
            ''' % inputs)
        ret = var
    return ret

def get_variadic(inputs):
    for name, i in inputs.items():
        if i.get('variadic', False):
            return name, i
    return None

def has_optional(inputs):
    ret = False
    for i in inputs.values():
        opt = i.get('optional', False)
        if ret and not opt:
            raise ValueError('''Optional input must come at the last of inputs.
            %s
            ''' % inputs)
        ret = opt
    return ret

def is_valid_rhs(rhs):
    try:
        eval(rhs)
        return True
    except:
        return False
        
def as_args(inputs, with_opt=True):
    a = ''
    for name, i in inputs.items():
        if i.get('variadic', False):
            a += ', *' + name
        else:
            a += ', ' + name
        if not with_opt:
            continue
        if 'default' in i:
            if is_valid_rhs(i['default']):
                a += '=' + i['default']
            else:
                a += '=None'
        elif i.get('optional', False):
            a += '=None'
    return a

def indent_lines(s, n):
    return s.replace('\n', '\n' + ' ' * n)

def type_doc(t):
    if t == 'Shape':
        return ':obj:`tuple` of :obj:`int`'
    elif t == 'int64':
        return 'int'
    elif t == 'double':
        return 'float'
    return t

def arg_options(arg):
    ret = []
    if arg.get('optional', False):
        ret.append('[optional]')
    if arg.get('variadic', False):
        ret.append('[variadic]')
    if arg.get('parameter', False):
        ret.append('[parameter]')
    if 'default' in arg:
        ret.append('[default= `%s` ]' % arg['default'])
    if ret:
        return ''.join(ret)
    return ''

def get_input_name(name, i):
    if i.get('variadic', False):
        return '*' + name
    return name

def get_min_inputs(inputs):
    ret = 0
    for name, i in inputs.items():
        if not i.get('optional', False):
           ret += 1
    return ret

def as_passed_inputs(inputs):
    ret = []
    for name, i in inputs.items():
        if i.get('optional', False):
            return ['*inputs']
        prefix = ''
        if i.get('variadic', False):
            prefix = '*'
        ret.append(prefix + name)
    return ret

def filter_inputs(inputs, optional=False):
    from collections import OrderedDict
    ret = OrderedDict()
    for name, i in inputs.items():
        if optional ^ i.get('optional', False):
            continue
        ret[name] = i
    return ret
%>
% for name, func in function_info.items():
<%
arguments = func.get('arguments', {})
variadic = has_variadic(func['inputs'])
min_inputs = get_min_inputs(func['inputs'])
%>


@function_api
% if variadic:
def ${func['snake_name']}(ctx${as_args(func['inputs'])}, **kw):
% else:
def ${func['snake_name']}(ctx${as_args(func['inputs'])}${as_args(arguments)}, n_outputs=-1, outputs=None):
% endif
    ${'r'}"""${indent_lines(func['doc'], 4)}
    Args:
% for iname, i in func['inputs'].items():
        ${get_input_name(iname, i)}(~nnabla.Variable): ${indent_lines(i['doc'], 12)}
% if arg_options(i):
            ${arg_options(i)}
% endif
% endfor
% for argname, arg in arguments.items():
        ${argname}(${type_doc(arg['type'])}): ${indent_lines(arg['doc'], 12)}
% if arg_options(arg):
            ${arg_options(arg)}
% endif
% endfor

    Returns:
% for oname, o in func['outputs'].items():
        ~nnabla.Variable: ${indent_lines(o['doc'], 12)}
% if arg_options(o):
            ${arg_options(o)}
% endif
% endfor
    """
% if variadic:
    assert len(${get_variadic(func['inputs'])[0]}) >= ${min_inputs}, "${func['snake_name']} must take more than ${min_inputs} inputs"
    n_outputs = kw.pop('n_outputs', -1)
    outputs = kw.pop('outputs', None)
% for argname, arg in arguments.items():
    ${argname} = kw.pop('${argname}', ${arg['default']})
% endfor
% else:
% for argname, arg in arguments.items():
% if 'default' in arg and not is_valid_rhs(arg['default']):
    if ${argname} is None:
        ${argname} = ${arg['default']}
% endif
% endfor
% endif
% if has_optional(func['inputs']):
    inputs = [${', '.join(filter_inputs(func['inputs']).keys())}]
% for iname, i in filter_inputs(func['inputs'], True).items():
    if ${iname} is not None:
        inputs += [${iname}]
% endfor
% endif
    return F.${name}(ctx${as_args(arguments, False)})(${', '.join(as_passed_inputs(func['inputs']) + ['n_outputs=n_outputs, auto_forward=get_auto_forward(), outputs=outputs'])})
% endfor

